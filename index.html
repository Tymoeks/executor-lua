
<!DOCTYPE html>
<html lang="pl">
<head>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Executor Lua</title>
    <style>
        /* Base styles and blue theme */
        :root {
            --primary-blue: #1e88e5;
            --dark-blue: #0d47a1;
            --light-blue: #64b5f6;
            --very-light-blue: #bbdefb;
            --dark-bg: #1e1e2e;
            --medium-bg: #2d2d3a;
            --light-bg: #3d3d4a;
            --text-light: #f5f5f5;
            --text-dark: #333;
            --keyword-red: #3499d3;
            --keyword-orange: #ffb62e;
            --bfunction: #8fe2f7;
            --library: #6ad3ee;
            --dotf: #30c5eb;
            --editor-font: 'Fira Code', 'Courier New', monospace;
            --editor-font-size: 16px;
            --editor-line-height: 1.5;
            --default-text: #d4d4d4; /* Light gray for default text */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--dark-bg);
            color: var(--text-light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }
        
        /* Header styles */
        header {
            background-color: var(--medium-bg);
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
        }
        
        .title {
            color: var(--primary-blue);
            font-size: 1.5rem;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        
        .title:hover {
            color: var(--light-blue);
        }
        
        /* Main container */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
        }
        
        /* Code editor section */
        .editor-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 300px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.3s ease;
            background-color: var(--dark-bg);
        }
        
        .editor-container:hover {
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        }
        
        .editor-wrapper {
            display: flex;
            flex: 1;
            position: relative;
        }
        
        .line-numbers {
            background-color: var(--medium-bg);
            padding: 10px 8px;
            text-align: right;
            color: var(--light-blue);
            user-select: none;
            opacity: 0.7;
            border-right: 1px solid var(--light-bg);
            overflow: hidden;
            font-family: var(--editor-font);
            font-size: var(--editor-font-size);
            line-height: var(--editor-line-height);
            min-width: 45px;
        }
        
        .code-editor {
            flex: 1;
            background-color: var(--dark-bg);
            color: transparent; /* Make text transparent */
            caret-color: var(--default-text); /* Keep cursor visible */
            padding: 10px;
            border: none;
            outline: none;
            resize: none;
            font-family: var(--editor-font);
            font-size: var(--editor-font-size);
            line-height: var(--editor-line-height);
            tab-size: 4;
            overflow: auto;
            white-space: pre;
        }
        
        /* Make selection visible but semi-transparent */
        .code-editor::selection {
            background-color: rgba(100, 181, 246, 0.4);
            color: transparent;
        }
        
        #highlight-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            margin-left: 45px; /* Match line numbers width */
            padding: 10px;
            font-family: var(--editor-font);
            font-size: var(--editor-font-size);
            line-height: var(--editor-line-height);
            white-space: pre;
            overflow: hidden;
            letter-spacing: normal;
            color: var(--default-text); /* Default text color */
        }
        
        /* Make sure all syntax highlighting elements inherit font properties */
        #highlight-layer span {
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            letter-spacing: inherit;
            font-weight: inherit;
            white-space: pre;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }
        
        ::-webkit-scrollbar-thumb {
            background-color: var(--light-bg);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--light-blue);
        }
        
        /* Button section */
        .button-section {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }
        
        .btn {
            padding: 0.6rem 1.4rem;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.05rem; /* Slightly larger font */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-run {
            background-color: var(--primary-blue);
            color: white;
        }
        
        .btn-run:hover {
            background-color: var(--dark-blue);
            transform: translateY(-2px);
        }
        
        .btn-clear {
            background-color: var(--medium-bg);
            color: var(--text-light);
            border: 1px solid var(--light-bg);
        }
        
        .btn-clear:hover {
            background-color: var(--light-bg);
            transform: translateY(-2px);
        }
        
        /* Output controls */
        .output-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .output-title {
            font-size: 1.1rem;
            color: var(--light-blue);
        }
        
        .filter-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .filter-toggle {
            background-color: var(--medium-bg);
            border: 1px solid var(--light-bg);
            color: var(--text-light);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem; /* Added font size increase */
        }
        
        .filter-toggle.active {
            background-color: var(--primary-blue);
            border-color: var(--primary-blue);
        }
        
        /* Output section */
        .output-section {
            background-color: var(--medium-bg);
            border-radius: 8px;
            padding: 1rem;
            flex: 1;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
        }
        
        .output-section:hover {
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        }
        
        /* Output message styling */
        .output-message {
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-radius: 4px;
            animation: fadeIn 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        .message-timestamp {
            color: var(--light-blue);
        }
        
        .message-type {
            font-weight: bold;
        }
        
        .message-type.print {
            color: var(--light-blue);
        }
        
        .message-type.błąd {
            color: #e02727;
        }
        
        .message-content {
            background-color: var(--dark-bg);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: var(--editor-font);
            word-break: break-word;
        }
        
        /* Syntax highlighting */
        .string {
            color: #8db85b;
        }
        
        .number {
            color: #ffb74d;
        }
        
        .comment {
            color: #697e88;
            font-style: italic;
        }
        
        .function {
            color: #fcf595;
        }
        
        .plain {
            color: var(--default-text);
        }
        
        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .pulse {
            animation: pulse 0.5s ease;
        }
        
        /* Autocomplete styles */
        .autocomplete-box {
            position: absolute; /* Zmiana z fixed na absolute */
            bottom: 10px; /* Odstęp od dolnej krawędzi */
            right: 10px; /* Odstęp od prawej krawędzi */
            max-height: 200px;
            width: 240px;
            overflow-y: auto;
            background-color: var(--medium-bg);
            border: 1px solid var(--light-bg);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
        }
        
        .autocomplete-item {
            padding: 6px 12px;
            cursor: pointer;
            font-family: var(--editor-font);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .autocomplete-item:hover, .autocomplete-item.selected {
            background-color: var(--primary-blue);
        }
        
        .autocomplete-text {
            flex: 1;
        }
        
        .autocomplete-type {
            margin-left: 10px;
            font-size: 0.8em;
            opacity: 0.7;
            padding: 2px 6px;
            border-radius: 3px;
            background-color: var(--dark-bg);
        }
        
        .wyrażenie-type    { color: var(--keyword-red); }
        .wartość-type   { color: var(--keyword-orange); }
        .funkcja-type   { color: var(--bfunction); }
        .biblioteka-type    { color: var(--library); }
        .matematyka-type       { color: var(--dotf); }
        .ciąg-type     { color: var(--dotf); }
        .tablica-type      { color: var(--dotf); }
        .io-type         { color: var(--dotf); }        /* New: IO library functions */
        .os-type         { color: var(--dotf); }        /* New: OS library functions */
        .package-type    { color: var(--dotf); }        /* New: Package library functions */
        .coroutine-type  { color: var(--dotf); }        /* New: Coroutine library functions */
        .debug-type      { color: var(--dotf); }        /* New: Debug library functions */

        .code-editor:not(:focus):not(:hover)::before,
        .code-editor:not(:focus):not(:hover)::after {
            display: none !important;
        }
        .code-editor::before,
        .code-editor::after,
        .code-editor ~ div[data-gramm],
        .code-editor ~ div.gr-textarea-btn,
        .code-editor ~ .grammarly-ghost,
        .code-editor ~ div[data-grammarly-part],
        .code-editor ~ grammarly-extension {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            width: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            z-index: -1 !important;
            pointer-events: none !important;
        }
    </style>
</head>
<body>
    <header>
        <h1 class="title">Executor Lua</h1>
    </header>
    
    <div class="container">
        <div class="editor-container">
            <div class="editor-wrapper">
                <div class="line-numbers" id="line-numbers">1</div>
                <textarea id="code-editor" class="code-editor" 
                spellcheck="false" 
                data-gramm="false"
                data-gramm_editor="false"
                autocorrect="off"
                autocapitalize="off"
                autocomplete="off">-- Pisz swój kod tutaj.
print(math.random(1, 5))</textarea>
                <div id="highlight-layer"></div>
                <div id="autocomplete-box" class="autocomplete-box"></div>
            </div>
        </div>
        
        <div class="button-section">
            <button id="run-btn" class="btn btn-run">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
                Uruchom Kod
            </button>
            <button id="clear-btn" class="btn btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M11 1.5v1h3.5a.5.5 0 0 1 0 1h-.538l-.853 10.66A2 2 0 0 1 11.115 16h-6.23a2 2 0 0 1-1.994-1.84L2.038 3.5H1.5a.5.5 0 0 1 0-1H5v-1A1.5 1.5 0 0 1 6.5 0h3A1.5 1.5 0 0 1 11 1.5Zm-5 0v1h4v-1a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5ZM4.5 5.029l.5 8.5a.5.5 0 1 0 .998-.06l-.5-8.5a.5.5 0 1 0-.998.06Zm6.53-.528a.5.5 0 0 0-.528.47l-.5 8.5a.5.5 0 0 0 .998.058l.5-8.5a.5.5 0 0 0-.47-.528ZM8 4.5a.5.5 0 0 0-.5.5v8.5a.5.5 0 0 0 1 0V5a.5.5 0 0 0-.5-.5Z"/>
                </svg>
                Wyczyść Dane Wyjściowe
            </button>
        </div>
        
        <div class="output-controls">
            <div class="output-title">Wyjście</div>
            <div class="filter-controls">
                <button class="filter-toggle active" data-filter="all">Wszystko</button>
                <button class="filter-toggle" data-filter="print">Print'y</button>
                <button class="filter-toggle" data-filter="błąd">Błędy</button>
            </div>
        </div>
        
        <div class="output-section" id="output">
            <!-- Output messages will appear here -->
        </div>
    </div>
    
    <!-- Embedding Fengari Lua VM (minimized) -->
    <script src="https://cdn.jsdelivr.net/npm/fengari-web@0.1.4/dist/fengari-web.js"></script>
    
    <script>
        // DOM elements
        const codeEditor = document.getElementById("code-editor");
        const highlightLayer = document.getElementById("highlight-layer");
        const lineNumbers = document.getElementById("line-numbers");
        const runBtn = document.getElementById("run-btn");
        const clearBtn = document.getElementById("clear-btn");
        const outputElement = document.getElementById("output");
        const filterButtons = document.querySelectorAll(".filter-toggle");
        const autocompleteBox = document.getElementById("autocomplete-box");
        
        // Current filter
        let currentFilter = "all";
        
        // Autocomplete variables
        let selectedAutocompleteIndex = -1;
        let autocompleteVisible = false;
        let currentSuggestions = [];
        
        // Define autocomplete suggestions
        const autocompleteItems = [
            // Lua keywords
            { text: "function", type: "wyrażenie" },
            { text: "if", type: "wyrażenie" },
            { text: "then", type: "wyrażenie" },
            { text: "end", type: "wyrażenie" },
            { text: "return", type: "wyrażenie" },
            { text: "local", type: "wyrażenie" },
            { text: "for", type: "wyrażenie" },
            { text: "while", type: "wyrażenie" },
            { text: "repeat", type: "wyrażenie" },
            { text: "until", type: "wyrażenie" },
            { text: "else", type: "wyrażenie" },
            { text: "elseif", type: "wyrażenie" },
            { text: "do", type: "wyrażenie" },
            { text: "and", type: "wyrażenie" },
            { text: "or", type: "wyrażenie" },
            { text: "not", type: "wyrażenie" },
            { text: "in", type: "wyrażenie" },
            { text: "break", type: "wyrażenie" },
            { text: "self", type: "wyrażenie" },
            { text: "goto", type: "wyrażenie" },

            // Basic functions
            { text: "print", type: "funkcja" },
            { text: "tonumber", type: "funkcja" },
            { text: "tostring", type: "funkcja" },
            { text: "type", type: "funkcja" },
            { text: "pairs", type: "funkcja" },
            { text: "ipairs", type: "funkcja" },
            { text: "pcall", type: "funkcja" },
            { text: "error", type: "funkcja" },
            { text: "assert", type: "funkcja" },
            { text: "collectgarbage", type: "funkcja" },
            { text: "dofile", type: "funkcja" },
            { text: "getmetatable", type: "funkcja" },
            { text: "load", type: "funkcja" },
            { text: "loadfile", type: "funkcja" },
            { text: "next", type: "funkcja" },
            { text: "rawequal", type: "funkcja" },
            { text: "rawget", type: "funkcja" },
            { text: "rawset", type: "funkcja" },
            { text: "select", type: "funkcja" },
            { text: "setmetatable", type: "funkcja" },
            { text: "xpcall", type: "funkcja" },

            // Libraries
            { text: "math", type: "biblioteka" },
            { text: "string", type: "biblioteka" },
            { text: "table", type: "biblioteka" },
            { text: "io", type: "biblioteka" },
            { text: "os", type: "biblioteka" },
            { text: "package", type: "biblioteka" },
            { text: "coroutine", type: "biblioteka" },
            { text: "debug", type: "biblioteka" },

            // Math functions
            { text: "math.random", type: "matematyka" },
            { text: "math.floor", type: "matematyka" },
            { text: "math.ceil", type: "matematyka" },
            { text: "math.abs", type: "matematyka" },
            { text: "math.max", type: "matematyka" },
            { text: "math.min", type: "matematyka" },
            { text: "math.sqrt", type: "matematyka" },
            { text: "math.pi", type: "matematyka" },
            { text: "math.sin", type: "matematyka" },
            { text: "math.cos", type: "matematyka" },
            { text: "math.tan", type: "matematyka" },
            { text: "math.rad", type: "matematyka" },
            { text: "math.deg", type: "matematyka" },
            { text: "math.log", type: "matematyka" },
            { text: "math.fmod", type: "matematyka" },
            { text: "math.pow", type: "matematyka" },
            { text: "math.modf", type: "matematyka" },
            { text: "math.atan", type: "matematyka" },
            { text: "math.asin", type: "matematyka" },
            { text: "math.acos", type: "matematyka" },
            { text: "math.exp", type: "matematyka" },
            { text: "math.log10", type: "matematyka" },
            { text: "math.randomseed", type: "matematyka" },
            { text: "math.huge", type: "matematyka" },
            { text: "math.atan2", type: "matematyka" },
            { text: "math.sinh", type: "matematyka" },
            { text: "math.cosh", type: "matematyka" },
            { text: "math.tanh", type: "matematyka" },
            { text: "math.ldexp", type: "matematyka" },

            // String functions
            { text: "string.len", type: "ciąg" },
            { text: "string.sub", type: "ciąg" },
            { text: "string.find", type: "ciąg" },
            { text: "string.match", type: "ciąg" },
            { text: "string.gsub", type: "ciąg" },
            { text: "string.lower", type: "ciąg" },
            { text: "string.upper", type: "ciąg" },
            { text: "string.format", type: "ciąg" },
            { text: "string.byte", type: "ciąg" },
            { text: "string.char", type: "ciąg" },
            { text: "string.rep", type: "ciąg" },
            { text: "string.reverse", type: "ciąg" },
            { text: "string.gmatch", type: "ciąg" },
            { text: "string.dump", type: "ciąg" },
        
            // Table functions
            { text: "table.insert", type: "tablica" },
            { text: "table.remove", type: "tablica" },
            { text: "table.concat", type: "tablica" },
            { text: "table.sort", type: "tablica" },
            { text: "table.unpack", type: "tablica" },
            { text: "table.move", type: "tablica" },

            // Posortowane według częstotliwości użycia:
            { text: "io.open", type: "io" },
            { text: "io.read", type: "io" },
            { text: "io.write", type: "io" },
            { text: "io.lines", type: "io" },
            { text: "io.close", type: "io" },
            { text: "io.input", type: "io" },
            { text: "io.output", type: "io" },
            { text: "io.popen", type: "io" },
            { text: "io.flush", type: "io" },
            { text: "io.tmpfile", type: "io" },
            { text: "io.type", type: "io" },


            // Posortowane według częstotliwości użycia:
            { text: "os.time", type: "os" },
            { text: "os.date", type: "os" },
            { text: "os.clock", type: "os" },
            { text: "os.execute", type: "os" },
            { text: "os.getenv", type: "os" },
            { text: "os.remove", type: "os" },
            { text: "os.rename", type: "os" },
            { text: "os.exit", type: "os" },
            { text: "os.difftime", type: "os" },
            { text: "os.setlocale", type: "os" },


            // Posortowane według częstotliwości użycia:
            { text: "package.require", type: "package" },
            { text: "package.path", type: "package" },
            { text: "package.cpath", type: "package" },
            { text: "package.config", type: "package" },
            { text: "package.searchpath", type: "package" },
            { text: "package.loadlib", type: "package" },
            { text: "package.preload", type: "package" },
            { text: "package.loaded", type: "package" },
            { text: "package.module", type: "package" },


            // Posortowane według częstotliwości użycia:
            { text: "coroutine.create", type: "coroutine" },
            { text: "coroutine.resume", type: "coroutine" },
            { text: "coroutine.yield", type: "coroutine" },
            { text: "coroutine.wrap", type: "coroutine" },
            { text: "coroutine.status", type: "coroutine" },
            { text: "coroutine.running", type: "coroutine" },


            // Posortowane według częstotliwości użycia:
            { text: "debug.getinfo", type: "debug" },
            { text: "debug.debug", type: "debug" },
            { text: "debug.getupvalue", type: "debug" },
            { text: "debug.setupvalue", type: "debug" },
            { text: "debug.gethook", type: "debug" },
            { text: "debug.sethook", type: "debug" },
            { text: "debug.getlocal", type: "debug" },
            { text: "debug.setlocal", type: "debug" },
            { text: "debug.getmetatable", type: "debug" },
            { text: "debug.getregistry", type: "debug" },

            // Values
            { text: "true", type: "wartość" },
            { text: "false", type: "wartość" },
            { text: "nil", type: "wartość" }
        ];
        
        // Line numbers functionality
        function updateLineNumbers() {
            const lines = codeEditor.value.split("\n");
            lineNumbers.innerHTML = Array.from({length: lines.length}, (_, i) => i + 1).join("<br>");
        }
        
        // Funkcja pozycjonująca boks autouzupełniania w prawym dolnym rogu edytora
        function positionAutocompleteBox() {
            const editorRect = codeEditor.getBoundingClientRect();
            
            // Ustaw pozycję w prawym dolnym rogu z odstępem
            autocompleteBox.style.left = (editorRect.right - 245) + 'px';
            autocompleteBox.style.top = (editorRect.bottom - 205) + 'px';
        }
        
// Autocomplete functionality
function showAutocomplete() {
    const cursorPos = codeEditor.selectionStart;
    const text = codeEditor.value.substring(0, cursorPos);

    // Find the partial word before cursor
    const wordRegex = /[\w\.]*$/;
    const match = text.match(wordRegex);

    if (match && match[0]) {
        const partialWord = match[0].toLowerCase();

        // Znalezienie najlepszego dopasowania do pełnego słowa
        const bestMatch = autocompleteItems.find(item => item.text.toLowerCase().startsWith(partialWord));

        if (!bestMatch) {
            hideAutocomplete();
            return;
        }

        const fullWord = bestMatch.text.toLowerCase();
        const minLength = Math.ceil(fullWord.length * 0.2); // 25% pełnego słowa

        // Pokaż sugestie tylko, jeśli wpisano przynajmniej 25% długości słowa
        if (partialWord.length < minLength) {
            hideAutocomplete();
            return;
        }

        // Pobieranie dopasowanych sugestii
        currentSuggestions = autocompleteItems.filter(item => 
            item.text.toLowerCase().startsWith(partialWord) && 
            item.text.toLowerCase() !== partialWord
        );

        if (currentSuggestions.length > 0) {               
            // Populate suggestions
            autocompleteBox.innerHTML = '';
            currentSuggestions.forEach((suggestion, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.innerHTML = `
                    <span class="autocomplete-text">${suggestion.text}</span>
                    <span class="autocomplete-type ${suggestion.type}-type">${suggestion.type}</span>
                `;
                item.dataset.index = index;
                item.addEventListener('click', () => {
                    insertSuggestion(suggestion.text);
                });
                autocompleteBox.appendChild(item);
            });

            autocompleteBox.style.display = 'block';
            autocompleteVisible = true;
            selectedAutocompleteIndex = -1;
        } else {
            hideAutocomplete();
        }
    } else {
        hideAutocomplete();
    }
}
        
        function hideAutocomplete() {
            autocompleteBox.style.display = 'none';
            autocompleteVisible = false;
            selectedAutocompleteIndex = -1;
        }
        
        function insertSuggestion(suggestion) {
            const cursorPos = codeEditor.selectionStart;
            const text = codeEditor.value.substring(0, cursorPos);
            
            // Find the partial word before cursor
            const wordRegex = /[\w\.]*$/;
            const match = text.match(wordRegex);
            
            if (match) {
                const partialWord = match[0];
                const startPos = cursorPos - partialWord.length;
                
                // Replace the partial word with the suggestion
                codeEditor.value = 
                    codeEditor.value.substring(0, startPos) + 
                    suggestion + 
                    codeEditor.value.substring(cursorPos);
                
                // Move cursor to the end of the inserted suggestion
                codeEditor.selectionStart = codeEditor.selectionEnd = startPos + suggestion.length;
                
                // Update syntax highlighting
                updateLineNumbers();
                highlightSyntax();
                hideAutocomplete();
            }
        }
        
        function handleAutocompleteKeys(e) {
            if (!autocompleteVisible) return;
            
            const items = autocompleteBox.querySelectorAll('.autocomplete-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                // Remove selection from current item
                if (selectedAutocompleteIndex >= 0) {
                    items[selectedAutocompleteIndex].classList.remove('selected');
                }
                
                // Select next item
                selectedAutocompleteIndex = (selectedAutocompleteIndex + 1) % items.length;
                items[selectedAutocompleteIndex].classList.add('selected');
                
                // Scroll if needed
                items[selectedAutocompleteIndex].scrollIntoView({ block: 'nearest' });
            } 
            else if (e.key === 'ArrowUp') {
                e.preventDefault();
                // Remove selection from current item
                if (selectedAutocompleteIndex >= 0) {
                    items[selectedAutocompleteIndex].classList.remove('selected');
                }
                
                // Select previous item
                selectedAutocompleteIndex = (selectedAutocompleteIndex - 1 + items.length) % items.length;
                items[selectedAutocompleteIndex].classList.add('selected');
                
                // Scroll if needed
                items[selectedAutocompleteIndex].scrollIntoView({ block: 'nearest' });
            } 
            else if (e.key === 'Tab') {
                e.preventDefault();
                if (selectedAutocompleteIndex >= 0) {
                    insertSuggestion(currentSuggestions[selectedAutocompleteIndex].text);
                } else if (items.length > 0) {
                    insertSuggestion(currentSuggestions[0].text);
                }
            } 
            else if (e.key === 'Enter') {
                if (selectedAutocompleteIndex >= 0) {
                    e.preventDefault();
                    insertSuggestion(currentSuggestions[selectedAutocompleteIndex].text);
                } else {
                    hideAutocomplete();
                }
            } 
            else if (e.key === 'Escape') {
                e.preventDefault();
                hideAutocomplete();
            }
        }
        
// Syntax highlighting
function highlightSyntax() {
    let code = codeEditor.value;
            
    // Escape HTML entities first
    code = code.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
            
        // Define Lua keywords for highlighting
        const redkeywords = [
            "and", "break", "do", "else", "elseif", 
            "end", "for", "function", "if", "self",
            "in", "local", "not", "or", "repeat", 
            "return", "then", "until", "while"
        ];

        // Define keywords that should be orange
        const orangeKeywords = [
            "true", "false", "nil"
        ];

// Basic functions (core Lua functions)
const Functions = [
    "assert", "collectgarbage", "dofile", "error", "getmetatable", "ipairs",
    "load", "loadfile", "next", "pairs", "pcall", "print", "rawequal",
    "rawget", "rawset", "select", "setmetatable", "tonumber", "tostring",
    "type", "unpack", "xpcall" // added xpcall
];

// Standard libraries available in Lua
const Libraries = [
    "math", "table", "string", "io", "os", "package", "coroutine", "debug"
];

// Functions from the math library
const dotmath = [
    "random", "randomseed", "sqrt", "sin", "ceil", "floor",
    "abs", "acos", "asin", "atan", "atan2", "cos", "cosh", "deg",
    "exp", "fmod", "huge", "ldexp", "log", "log10", "max", "min",
    "modf", "pi", "pow", "rad", "sinh", "tanh"
];

// Functions from the table library
const dottable = [
    "insert", "remove", "sort", "concat", "move", "unpack"
];

// Functions from the string library
const dotstring = [
    "byte", "char", "dump", "find", "format", "gmatch",
    "gsub", "len", "lower", "match", "rep", "reverse",
    "sub", "upper"
];

// Functions from the io library
const dotio = [
    "close", "flush", "input", "lines", "open", "output",
    "popen", "read", "tmpfile", "type", "write"
];

// Functions from the os library
const dotos = [
    "clock", "date", "difftime", "execute", "exit", "getenv",
    "remove", "rename", "setlocale", "time"
];

// Functions from the package library
const dotpackage = [
    "loadlib", "searchpath", "preload", "loaded", "config",
    "path", "cpath", "require", "module"
];

// Functions from the coroutine library
const dotcoroutine = [
    "create", "resume", "running", "status", "wrap", "yield"
];

// Functions from the debug library
const dotdebug = [
    "debug", "gethook", "sethook", "getinfo", "getlocal",
    "setlocal", "getmetatable", "getregistry", "getupvalue", "setupvalue"
];

            // Store parts that should not be processed by other rules
            let parts = [];
            let processedCode = code;
            
            // Comments (store and replace with placeholder)
            processedCode = processedCode.replace(/(--.*?)($|\n)/g, function(match) {
                const placeholder = `###COMMENT${parts.length}###`;
                parts.push('<span class="comment">' + match + '</span>');
                return placeholder;
            });
            
            // Strings (store and replace with placeholder)
            processedCode = processedCode.replace(/(".*?"|'.*?')/g, function(match) {
                const placeholder = `###STRING${parts.length}###`;
                parts.push('<span class="string">' + match + '</span>');
                return placeholder;
            });
            
            // Numbers
            processedCode = processedCode.replace(/\b(\d+\.?\d*)\b/g, function(match) {
                const placeholder = `###NUMBER${parts.length}###`;
                parts.push('<span class="number">' + match + '</span>');
                return placeholder;
            });
            
            // Keywords (ensuring they are whole words)
            for (const keyword of redkeywords) {
                const regex = new RegExp(`\\b(${keyword})\\b`, 'g');
                processedCode = processedCode.replace(regex, function(match) {
                    const placeholder = `###RED${parts.length}###`;
                    // Add inline style for red and thick (bold) font
                    parts.push('<span class="red-keyword" style="color: var(--keyword-red); font-weight: bold;">' + match + '</span>');
                    return placeholder;
                });
            }

// Process math dot functions
for (const keyword of dotmath) {
    // Match 'math.' followed by the keyword
    const regex = new RegExp(`\\b(math\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process table dot functions
for (const keyword of dottable) {
    // Match 'table.' followed by the keyword
    const regex = new RegExp(`\\b(table\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process string dot functions
for (const keyword of dotstring) {
    // Match 'string.' followed by the keyword
    const regex = new RegExp(`\\b(string\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process io dot functions
for (const keyword of dotio) {
    // Match 'io.' followed by the keyword
    const regex = new RegExp(`\\b(io\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process os dot functions
for (const keyword of dotos) {
    // Match 'os.' followed by the keyword
    const regex = new RegExp(`\\b(os\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process package dot functions
for (const keyword of dotpackage) {
    // Match 'package.' followed by the keyword
    const regex = new RegExp(`\\b(package\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process coroutine dot functions
for (const keyword of dotcoroutine) {
    // Match 'coroutine.' followed by the keyword
    const regex = new RegExp(`\\b(coroutine\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

// Process debug dot functions
for (const keyword of dotdebug) {
    // Match 'debug.' followed by the keyword
    const regex = new RegExp(`\\b(debug\\.)(${keyword})\\b`, 'g');
    processedCode = processedCode.replace(regex, function(match, p1, p2) {
        const placeholder = `###BDOTFUNCTION${parts.length}###`;
        parts.push('<span class="bfunction" style="color: var(--dotf); font-weight: plain;">' + p2 + '</span>');
        return p1 + placeholder;
    });
}

            // Built-in functions with dot (only if preceded by a dot)
            for (const keyword of Functions) {
                const regex = new RegExp(`\\b(${keyword})\\b(?=\\()`, 'g');  // Match the keyword followed by '('
                processedCode = processedCode.replace(regex, function(match) {
                    const placeholder = `###BFUNCTION${parts.length}###`;
                    parts.push('<span class="bfunction" style="color: var(--bfunction); font-weight: plain;">' + match + '</span>');
                    return placeholder;
                });
            }

            // Orange Keywords
            for (const keyword of orangeKeywords) {
                const regex = new RegExp(`\\b(${keyword})\\b`, 'g');
                processedCode = processedCode.replace(regex, function(match) {
                    const placeholder = `###ORANGE${parts.length}###`;
                    parts.push('<span class="orange-keyword" style="color: var(--keyword-orange); font-weight: bold;">' + match + '</span>');
                    return placeholder;
                });
            }
            
            // Other function calls
            processedCode = processedCode.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, function(match, p1) {
                const placeholder = `###FUNCTION${parts.length}###`;
                parts.push('<span class="function">' + p1 + '</span>(');
                return placeholder;
            });

            for (const keyword of Libraries) {
                const regex = new RegExp(`\\b(${keyword})\\b`, 'g');
                processedCode = processedCode.replace(regex, function(match) {
                    const placeholder = `###BFUNCTION${parts.length}###`;
                    parts.push('<span class="bfunction" style="color: var(--library); font-weight: plain;">' + match + '</span>');
                    return placeholder;
                });
            }
            
            // Now wrap any remaining text in plain spans
            let finalResult = '';
            let lastIndex = 0;
            
            // Regular expression to match all placeholders
            const placeholderRegex = /###(COMMENT|STRING|NUMBER|FUNCTION|RED|ORANGE|BDOTFUNCTION|BFUNCTION)(\d+)###/g;
            let match;
            
            while ((match = placeholderRegex.exec(processedCode)) !== null) {
                // Add plain text before the placeholder
                if (match.index > lastIndex) {
                    const plainText = processedCode.substring(lastIndex, match.index);
                    finalResult += '<span class="plain">' + plainText + '</span>';
                }
                
                // Add the preserved part for this placeholder
                const partIndex = parseInt(match[2]);
                finalResult += parts[partIndex];
                
                lastIndex = match.index + match[0].length;
            }
            
            // Add any remaining text
            if (lastIndex < processedCode.length) {
                const plainText = processedCode.substring(lastIndex);
                finalResult += '<span class="plain">' + plainText + '</span>';
            }
            
            // Update the highlight layer
            highlightLayer.innerHTML = finalResult;
            
            // Sync scroll position with the editor
            highlightLayer.scrollTop = codeEditor.scrollTop;
            highlightLayer.scrollLeft = codeEditor.scrollLeft;
        }
        
        // Initialize editor
        function initializeEditor() {
            updateLineNumbers();
            highlightSyntax();
            
            // Event listeners
            codeEditor.addEventListener("input", function() {
                updateLineNumbers();
                highlightSyntax();
                showAutocomplete();
            });
            
            codeEditor.addEventListener("scroll", function() {
                highlightLayer.scrollTop = codeEditor.scrollTop;
                highlightLayer.scrollLeft = codeEditor.scrollLeft;
            });
            
            codeEditor.addEventListener("keydown", function(e) {
                if (autocompleteVisible) {
                    // Handle autocomplete navigation
                    if (['ArrowDown', 'ArrowUp', 'Enter', 'Tab', 'Escape'].includes(e.key)) {
                        handleAutocompleteKeys(e);
                        return;
                    }
                }
                
                // Ukryj autocomplete przy zmianie linii
                if (e.key === "Enter") {
                    hideAutocomplete();
                }
                
                if (e.key === "Tab") {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert 4 spaces at cursor position
                    this.value = this.value.substring(0, start) + "    " + this.value.substring(end);
                    
                    // Move cursor position
                    this.selectionStart = this.selectionEnd = start + 4;
                    
                    // Update highlighting
                    updateLineNumbers();
                    highlightSyntax();
                }
            });
            
            // Obsługa utraty fokusu - ukryj autocomplete
            codeEditor.addEventListener("blur", function(e) {
                // Dodaj małe opóźnienie, aby można było kliknąć opcję z autocomplete
                setTimeout(hideAutocomplete, 200);
            });
            
            // Ukryj box przy kliknięciu poza nim
            document.addEventListener("click", function(e) {
                if (!autocompleteBox.contains(e.target) && e.target !== codeEditor) {
                    hideAutocomplete();
                }
            });
        }
        
        // Run Lua code
        function runLuaCode() {
            const code = codeEditor.value;
    
            // Create a timestamp
            const timestamp = new Date().toLocaleTimeString();
            
            try {
                // Create a new Lua state
                const L = fengari.lauxlib.luaL_newstate();
                
                // Load Lua standard libraries
                fengari.lualib.luaL_openlibs(L);
                
                // Custom print function to capture output
                const printFunction = function(L) {
                    const nargs = fengari.lua.lua_gettop(L);
                    let message = '';
                    
                    for (let i = 1; i <= nargs; i++) {
                        message += fengari.lua.lua_tojsstring(L, i);
                        if (i < nargs) message += '\t';
                    }

                    if (message.trim() === '') {
                        message = 'null';
                    }
                    
                    // Add the captured output to our display
                    addOutputMessage("print", message, timestamp);
                    
                    return 0;
                };
                
                // Override the print function
                fengari.lua.lua_pushcfunction(L, printFunction);
                fengari.lua.lua_setglobal(L, 'print');
                
                // Run the code
                const status = fengari.lauxlib.luaL_dostring(L, fengari.to_luastring(code));
                
                // Handle errors
                if (status !== fengari.lua.LUA_OK) {
                    const errorMsg = fengari.lua.lua_tojsstring(L, -1);
                    addOutputMessage("błąd", errorMsg, timestamp);
                } else {
                    // Add success message
                    addOutputMessage("info", "Kod wykonany pomyślnie.", timestamp);
                }
                
            } catch (error) {
                // Handle errors
                addOutputMessage("błąd", error.message, timestamp);
            }
            
            // Apply animation to the run button
            runBtn.classList.add("pulse");
            setTimeout(() => runBtn.classList.remove("pulse"), 500);
            
            // Filter messages based on current filter
            applyFilter();
        }
        
        // Add message to output
        function addOutputMessage(type, content, timestamp) {
            const messageElement = document.createElement("div");
            messageElement.className = `output-message ${type}`;
            messageElement.dataset.type = type;
            
            const header = document.createElement("div");
            header.className = "message-header";
            
            const typeSpan = document.createElement("span");
            typeSpan.className = `message-type ${type}`;
            typeSpan.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            
            const timestampSpan = document.createElement("span");
            timestampSpan.className = "message-timestamp";
            timestampSpan.textContent = timestamp;
            
            header.appendChild(typeSpan);
            header.appendChild(timestampSpan);
            
            const messageContent = document.createElement("div");
            messageContent.className = "message-content";
            messageContent.textContent = content;
            
            messageElement.appendChild(header);
            messageElement.appendChild(messageContent);
            
            outputElement.appendChild(messageElement);
            
            // Scroll to the bottom of output
            outputElement.scrollTop = outputElement.scrollHeight;
        }
        
        // Clear output
        function clearOutput() {
            outputElement.innerHTML = "";
        }
        
        // Filter output messages
        function applyFilter() {
            const messages = outputElement.querySelectorAll(".output-message");
            
            messages.forEach(message => {
                if (currentFilter === "all" || message.dataset.type === currentFilter) {
                    message.style.display = "flex";
                } else {
                    message.style.display = "none";
                }
            });
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Run button
            runBtn.addEventListener("click", runLuaCode);
            
            // Clear button
            clearBtn.addEventListener("click", clearOutput);
            
            // Filter buttons
            filterButtons.forEach(button => {
                button.addEventListener("click", function() {
                    // Update active filter
                    filterButtons.forEach(btn => btn.classList.remove("active"));
                    this.classList.add("active");
                    
                    // Set filter and apply
                    currentFilter = this.dataset.filter;
                    applyFilter();
                });
            });
            
            // Run code on Ctrl+Enter
            codeEditor.addEventListener("keydown", function(e) {
                if (e.ctrlKey && e.key === "Enter") {
                    runLuaCode();
                }
            });
        }
        
        // Initialize everything
        window.addEventListener("load", function() {
            initializeEditor();
            setupEventListeners();
            highlightSyntax(); // Initial highlighting
        });
    </script>
</body>
</html>
